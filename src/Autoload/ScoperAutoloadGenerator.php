<?php

declare(strict_types=1);

/*
 * This file is part of the humbug/php-scoper package.
 *
 * Copyright (c) 2017 Théo FIDRY <theo.fidry@gmail.com>,
 *                    Pádraic Brady <padraic.brady@gmail.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Humbug\PhpScoper\Autoload;

use Humbug\PhpScoper\Symbol\SymbolsRegistry;
use PhpParser\Node\Name\FullyQualified;
use function array_keys;
use function array_map;
use function array_unshift;
use function chr;
use function count;
use function explode;
use function implode;
use function sprintf;
use function str_repeat;
use function str_replace;
use function usort;

final class ScoperAutoloadGenerator
{
    // TODO: aliasing functions could be done via a single function to reduce boiler-template.

    private const FUNCTION_ALIASES_DOC = <<<'EOF'
        // Function aliases. For more information see:
        // https://github.com/humbug/php-scoper/blob/master/docs/further-reading.md#function-aliases
        EOF;

    private const CLASS_ALIASES_DOC = <<<'EOF'
        // Class aliases. For more information see:
        // https://github.com/humbug/php-scoper/blob/master/docs/further-reading.md#class-aliases
        EOF;

    private const EXPOSE_CLASS_DECLARATION = <<<'PHP'
        function humbug_phpscoper_expose_class(string $exposed, string $prefixed): void {
            if (!class_exists($exposed, false) && !interface_exists($exposed, false) && !trait_exists($exposed, false)) {
                spl_autoload_call($prefixed);
            }
        }
        PHP;

    /** @var non-empty-string */
    private static string $eol;

    public function __construct(private readonly SymbolsRegistry $registry)
    {
        self::$eol = chr(10);
    }

    public function dump(): string
    {
        $exposedFunctions = self::sortExposedFunctions(
            $this->registry->getRecordedFunctions(),
        );

        $hasNamespacedFunctions = self::hasNamespacedFunctions($exposedFunctions);

        $statements = implode(
            self::$eol,
            self::createClassAliasStatementsSection(
                $this->registry->getRecordedClasses(),
                $hasNamespacedFunctions,
            ),
        )
            .self::$eol
            .self::$eol;
        $statements .= implode(
            self::$eol,
            self::createFunctionAliasStatements(
                $exposedFunctions,
                $hasNamespacedFunctions,
            ),
        );

        if ($hasNamespacedFunctions) {
            $dump = <<<PHP
                <?php

                // scoper-autoload.php @generated by PhpScoper

                namespace {
                    \$loader = require_once __DIR__.'/autoload.php';
                    require_once __DIR__.'/composer/InstalledVersions.php';
                }

                {$statements}

                namespace {
                    return \$loader;
                }

                PHP;
        } else {
            $dump = <<<PHP
                <?php

                // scoper-autoload.php @generated by PhpScoper

                \$loader = require_once __DIR__.'/autoload.php';
                require_once __DIR__.'/composer/InstalledVersions.php';

                {$statements}

                return \$loader;

                PHP;
        }

        return self::removeUnnecessaryLineReturns($dump);
    }

    /**
     * @param list<array{string, string}> $exposedFunctions
     *
     * @return list<array{string, string}>
     */
    private static function sortExposedFunctions(array $exposedFunctions): array
    {
        usort(
            $exposedFunctions,
            static fn (array $a, array $b) => $a[0] <=> $b[0],
        );

        return $exposedFunctions;
    }

    /**
     * @param list<array{string, string}> $exposedClasses
     *
     * @return list<string>
     */
    private static function createClassAliasStatementsSection(
        array $exposedClasses,
        bool $hasNamespacedFunctions
    ): array {
        $statements = self::createClassAliasStatements($exposedClasses);

        if (count($statements) === 0) {
            return [];
        }

        array_unshift($statements, self::EXPOSE_CLASS_DECLARATION);

        if ($hasNamespacedFunctions) {
            $statements = self::wrapStatementsInNamespaceBlock('', $statements);
        }

        array_unshift($statements, self::CLASS_ALIASES_DOC);

        return $statements;
    }

    /**
     * @param list<array{string, string}> $exposedClasses
     *
     * @return list<string>
     */
    private static function createClassAliasStatements(array $exposedClasses): array
    {
        return array_map(
            static fn (array $pair) => self::createClassAliasStatement(...$pair),
            $exposedClasses,
        );
    }

    private static function createClassAliasStatement(
        string $exposed,
        string $prefixed
    ): string {
        return sprintf(
            'humbug_phpscoper_expose_class(\'%s\', \'%s\');',
            $exposed,
            $prefixed,
        );
    }

    /**
     * @param list<string> $statements
     *
     * @return list<string>
     */
    private static function wrapStatementsInNamespaceBlock(string $namespace, array $statements): array
    {
        $indent = str_repeat(' ', 4);
        $indentLine = static fn (string $line) => $indent.$line;

        $statements = array_map(
            static function (string $statement) use ($indentLine): string {
                $parts = explode(self::$eol, $statement);

                return implode(
                    self::$eol,
                    array_map($indentLine, $parts),
                );
            },
            $statements,
        );

        array_unshift(
            $statements,
            sprintf(
                'namespace %s{',
                '' === $namespace ? '' : $namespace.' ',
            ),
        );
        $statements[] = '}'.self::$eol;

        return $statements;
    }

    /**
     * @param list<array{string, string}> $exposedFunctions
     *
     * @return list<string>
     */
    private static function createFunctionAliasStatements(
        array $exposedFunctions,
        bool $hasNamespacedFunctions
    ): array {
        $functionsGroupedByNamespace = self::groupFunctionsByNamespace($exposedFunctions);

        $statements = array_map(
            static fn (string $namespace) => self::createNamespacedFunctionAliasStatement(
                $hasNamespacedFunctions,
                $namespace,
                $functionsGroupedByNamespace[$namespace],
            ),
            array_keys($functionsGroupedByNamespace),
        );

        if ([] === $statements) {
            return $statements;
        }

        array_unshift($statements, self::FUNCTION_ALIASES_DOC);

        return $statements;
    }

    /**
     * @param list<array{string, string}> $exposedFunctions
     *
     * @return array<string, list<array{string, string, string}>>
     */
    private static function groupFunctionsByNamespace(array $exposedFunctions): array
    {
        $groupedFunctions = [];

        foreach ($exposedFunctions as [$original, $alias]) {
            $originalFQ = new FullyQualified($original);
            $namespace = $originalFQ->slice(0, -1);
            $functionName = null === $namespace ? $original : (string) $originalFQ->slice(1);

            $groupedFunctions[(string) $namespace][] = [$original, $functionName, $alias];
        }

        return $groupedFunctions;
    }

    /**
     * @param list<array{string, string, string}> $functions
     */
    private static function createNamespacedFunctionAliasStatement(
        bool $hasNamespacedFunctions,
        string $namespace,
        array $functions
    ): string {
        $statements = array_map(
            static fn (array $function) => self::createFunctionAliasStatement(...$function),
            $functions,
        );

        if ($hasNamespacedFunctions) {
            $statements = self::wrapStatementsInNamespaceBlock(
                $namespace,
                $statements,
            );
        }

        return implode(self::$eol, $statements);
    }

    private static function createFunctionAliasStatement(
        string $original,
        string $functionName,
        string $alias
    ): string {
        return sprintf(
            <<<'PHP'
                if (!function_exists('%s')) { function %s(%s) { return \%s(...func_get_args()); } }
                PHP,
            $original,
            $functionName,
            '__autoload' === $functionName ? '$className' : '',
            $alias,
        );
    }

    /**
     * @param list<array{string, string}> $functions
     */
    private static function hasNamespacedFunctions(array $functions): bool
    {
        foreach ($functions as [$original, $alias]) {
            $containsBackslash = str_contains($original, '\\');

            if ($containsBackslash) {
                return true;
            }
        }

        return false;
    }

    private static function removeUnnecessaryLineReturns(string $dump): string
    {
        $cleanedDump = $dump;

        do {
            $dump = $cleanedDump;
            $cleanedDump = str_replace("\n\n\n", "\n\n", $dump);
        } while ($cleanedDump !== $dump);

        return $dump;
    }
}
